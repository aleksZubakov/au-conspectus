## Поиск в ширину

```python
# Поиск с вершины w
BFS(G, w):
  for v = 1 to n:
    prev[v] = 0
    dist[v] = +inf

  Q = queue([ w ])
  dist[w] = 0


  while Q.size > 0:
    v = Q.deque()

    for u : (v, u) in E:       # пытаемся обойти всех соседей
      if dist[u] = +inf        # ещё не посетили
        dist[i] = dist[v] + 1
        prev[u] = v
        Q.enque(u)
```

Время $O(|V| + |E|)$, каждое ребро мы просмотрим однажды.

**Утверждение**: $\forall u: d[u] = dist(w, u)$.

Доказательство по индукции. База: $u = w \Rightarrow d[w] = dist(w, w) = 0$. Пусть верно для всех $u$ на расстоянии $\leqslant k \Rightarrow$ верно для $u$ на расстоянии $k + 1$. Найдём какую-нибудь вершину на расстоянии $k + 1$. Она является соседом для вершины $v$ на расстоянии $k$, когда мы дойдём до $v$, то мы добавим в очередь все вершины на расстоянии $k+1$ и потом правильно расставим расстояния.


**Утверждение**: пусть $\pi = (v, v_1, v_2, \ldots, v_k, u)$ — кратчайший путь из $v \rightsquigarrow u$. Тогда для $i, j (i < j) : \pi' = (v_i, \ldots, v_j)$ — тоже кратчайший путь $v_i \rightsquigarrow v_j$. То есть кратчайший подпуть тоже кратчайший.

Любой участок пути есть путь и он является кратчайшим путём, иначе (если бы был другой более короткий под путь) то мы могли бы оптимизировать исходный путь.


## Поиск кратчайших путей во взешенных графах

Обычный $BFS$ не справится (почему?), хотя можно разбить рёбра, например, веса $k$, на $k$ рёбер.

фиктивные вершины:
- требуют "целых" весов
- не работает с иррациональными весами
- требует много вершин, если веса большие _(самое плохое)_
- зависит от весов (экспоненциальный алгоритм, $2^L$, где $L$ — длина числа)


#### Алгоритм Дейкстры

Нам потребуется очередь с приоритетом, со следующим интерфейсом:
- `make_priority_queue`
- `extract_min`
- `decrease_key`
- `insert`

Алгоритм будет делать что-то очень похожее на $BFS$, но будем учитывать веса — они будут приоритетом, т.е. выбирать будем минимальный вес.

```python
# shortest path from vertex s
def sp_dijkstra(G, s):
  for v = 1 to n:
    dist[v] = +inf
    prev[v] = 0

  dist[s] = 0
  PQ = make_priority_queue([ (s, 0) ])  # приоритет — вес


  while PQ.size > 0:
    v, d = Q.extract_min()
    for (v, u) in E:
      # пытаемся либо обновить расстояние либо заменить его
      if dist[u] = +inf:
        dist[u] = dist[v] + w(u, v)  # w(e) — вес ребра
        prev[u] = v
        PQ.insrt((u, dist[u]))

      # вдруг путь от v более короткий?
      elif dist[u] > dist[v] + w(u, v):
        dist[u] = dist[v] + w(u, v)
        prev[u] = v
        PQ.decrease_key((u, dist[u]))
```

**Лемма**. Алгоритм Дейкстры корректен, т.е. $\forall v\ \ d[v] = dist(s, v)$. Очевидно, он корректн для вершин, которые находятся в другой компоненте связности (т.к. мы до них не дойдём и расстояние будет равно $\infty$).

Введём три множества $S \subset R \subset T$:
$S$ — вершины, которые мы уже обработали ($(v, d)$ в цикле while)
$R$ — вершины, в приоритетной очереди, являются соседями для $S$
$T$ — вершины с $dist[\ ] = +\infty$

Что значит, что вершина $r$ лежит в $R$? Это значит, что её соседей мы уже обработали (и потом положили $r$) и они лежат в $S$.

Утверждение: если $v$ переходит из $R \rightsquigarrow S$ (т.е. вытащили $v$ из $Q$) $\Rightarrow dist[v] = dist(s, v)$.

$\triangledown$ Пусть $v$ — вершина в очереди с самым маленьким расстоянием. Докажем по индукции. Предполагаем, что для всех вершин в $S$ расстояние корректно.

От противного. Пусть $\exists \pi = (s, v_1, v_2, \ldots, w, \ldots, v_k, v)$ — более короткий путь из $s \rightsquigarrow v$. Рассмотрим первую вершину этого пути, которая лежит в $R$ ($w$). Но в приоритетной очереди $v$ — от $S$ до неё самое короткое ребро. Тогда $dist[w] \geqslant dist[v] \Rightarrow |\pi| \geqslant dist[v]$. Кусок более короткого пути оказался длинее. $$

Сложность $O(V) + \text{make\_priority\_queue}\ +$ $ O(V)\cdot \text{insert}\ +$$\ O(V)\cdot \text{extract\_min}\ +$$\  O(E)\cdot\text{decrease\_key}$.

1. Куча: $O(V) + O(V) + O(V) \cdot \log V\ +$ $\ O(V)\cdot \log V + O(E) \log V$ $\ = O((V + E) \log V)$

2. Массив: $O(V) + O(V) + O(V) + O(V) \cdot O(V) + O(E) \cdot O(1) = O(V^2 + E)$

Если граф неплотный (разреженный, $E = O\left(\frac{V^2}{\log V}\right)$), то лучше куча. Если плотный ($E \sim V^2$), то лучше массив.

Алгоритм не работает на графе с отрицательными весами.

**NB**: можно улучшить при помощи $d$-ичной кучи, Если взять $d \approx \frac{E}{V}$. Проталкивание вниз сопровождается домножением на $d$, а вверх — нет, на этом и можно выйграть. Сложность будет порядка $O(E)$.
