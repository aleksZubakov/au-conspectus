# Максимальные независимые множества в деревьях

IS (independent set) (есть фотка)

Дан граф $G = (V, E)$. $IS$ — подмножество $V$: $\nexists\, u, v \in IS: (u, v) \in E$.
т.е. не существует пары вершин, которые соединены ребром

Задачу решаем снизу вверх: $IS[v]$ — размер max IS в поддереве с корнем в $v$.

1. $IS[\,l\,] = 1$, где $l$ — лист.
(В поддереве из одного элемента IS — сам элемент.)
<br>
2. $IS[v] = \max \{ \sum_{w - \text{внук v}}{IS[w] + 1}, \sum_{w - \text{сын}}{IS[w]} \}$

Асимптотика этого алгоритма линейна: каждая вершина поучаствует как корень 1 раз, как сын 1 раз и как внук 1 раз.


## Редакционное расстояние

> Так же имеет название "расстояние Левенштейна" или "edit distance".

**Вход**: s1 и s2 — строки

**Выход**: минимальное количество правок: s1 ~~> s2.

Правки:
1. Добавить букву
2. Удалить букву
3. Заменить букву


Пример: $s_1$ = `дождь`, $s_2$ = `дрожь`. Используя только замены нам потребуется три замены буквы (о → р, ж → о, д → ж). Можно и лучше, удалить букву д и добавить р. Таким образом $\textbf{ED}(s_1, s_2) = 2$.

Бывает ещё и "взвешенная" версия у этой задачи, где мы у каждой операции есть стоимость. Это задача связана с задачей о выравнивании.

### Задача о выравнивании

**Вход**: $s_1$ и $s_2$ — две строки
**Задача**: записать $s_2$ под $s_1$ так, чтобы количество различий было минимально.

```
дождь     количество различий сейчас равно трём
дрожь


д-ождь    здесь только два столбца
дрож-ь
```

Утверждение: задача о выравнивании для $s_1$ и $s_2$ имеет то же решение, что и $\textbf{ED}(s_1, s_2)$. (см. фотографию)

Задачу будем решать с помощью динамического программирования:

Допустим мы решили задачу для каких-то префиксов строк и хотим продвинуться на единицу дальше. Задача будет от двух индексов.

1. $E[\,i,j\,] = ED(s_1[1:i], s_2[1:j])$ — расстояние префиксов. $E[i, 0] = i, E[0, j] = j$.
<br>
2. $E[i, j] = min\{\ E[i,j-1]+1,\ E[i-1, j]+1,\ E[i-1, j-1] + [s_1[i] \neq s_2[j]]\    \}$

  > У s2 откусили, у s1 не откусили букву.
  У s1 была буква, её удалили у s2.
  Заменили букву на другую, но надо проверить, что это не та же самая буква.

  В случае взвешенных штук умножим единицы на веса.
  <br>
3. Как вычислять? см. фотографию
Можно по строкам, по столбцам, или как нарисовано, квадратами. Время работы: $O(|s_1| \cdot |s_2|)$, память $O(|s_1| \cdot |s_2|)$.

```
s1:  EXPONENTIAL  11
s2:  POLYNOMIAL   10
```

|       |    | P | O | L | Y | N | O | M | I | A | L |
|:-----:|:--:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|       | 0  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |
| **E** | `1`| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |
| **X** | `2`| 2 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |
| **P** | 3  |`2`| 3 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |
| **O** | 4  | 3 |`2`| 3 | 4 | 5 | 5 | 6 | 7 | 8 | 9 |
| **N** | 5  | 4 | 3 |`3`| 4 | 4 | 5 | 6 | 7 | 8 | 9 |
| **E** | 6  | 5 | 4 | 4 |`4`| 5 | 5 | 6 | 7 | 8 | 9 |
| **N** | 7  | 6 | 5 | 5 | 5 |`4`| 5 | 6 | 7 | 8 | 9 |
| **T** | 8  | 7 | 6 | 6 | 6 | 5 |`5`|`6`| 7 | 8 | 9 |
| **I** | 9  | 8 | 7 | 7 | 7 | 7 | 6 | 6 |`6`| 7 | 8 |
| **A** | 10 | 9 |`8`| 8 | 8 | 7 | 7 | 7 | 7 |`6`| 7 |
| **L** | 11 | 10| 9 | 8 | 8 | 8 | 8 | 8 | 8 | 7 |`6`|

Как восстанаваливать? При вставке числа нужно запоминать стрелку, откуда мы пришли. Хотя на самом деле можно восстановить по матрице от правого нижнего угла, выбирая минимум из трёх клеток и перемещаясь туда.

```
É X P O Ń É N T - I A L
- - P O L Y N O M I A L
```

Будем считать, что мы заполняем по столбцам. Можно решить за $O(\min(|s_1|, |s_2|))$ памяти, если хранить текущий столбец (от ячейки вверх) и кусочек предыдущего (шаг влево и всё до низа). Но не будет возможности восстановить последовательность редактирований.


## Алгоритм Хиршберга

Лемма 1. $\textbf{ED}(s_1, s_2) = \textbf{ED}(\texttt{rev}(s_1), \texttt{rev}(s_2))$.

Лемма 2. $s_2 = s_{2_1} \circ s_{2_2}$ — разбиение $s_2$ на две строки. Тогда $\exists i:\ \textbf{ED}(s_1, s_2) = \textbf{ED}(s_1[1:i], s_{2_1}) + \textbf{ED}(s_1[i+1:n], s_{2_2})$.

$\forall i\ \ \ \ \ \textbf{ED}(s_1, s_2) \geqslant \textbf{ED}(s_1[1:i], s_{2_1}) + \textbf{ED}(s_1[i+1:n], s_{2_2})$.

Доказательство. <!-- Рассмотрим выравнивание $s_1$ и $s_2$.  --> Его по сути нет, но на экзамене будет :'(

Следствие: $] s_2 = s_{2_1} \circ s_{2_2} \Rightarrow \exists i: \textbf{ED}(s_1, s_2) = \textbf{ED}(s_1[1:i], s_{2_1}) + \textbf{ED}(s_1[n:i+1], \texttt{rev}(s_{2_2}))$.


Используя леммы будем делать так:

1. Разделим $s_2$ пополам. $s_2 = s_{2_1} \circ s_{2_2}$.
2. Решаем задачу для $s_1$ и $s_{2_1}$.
3. Решаем задачу для $\texttt{rev}(s_1)$ и $\texttt{rev}(s_{2_2})$ за $O(s_1)$ памяти.
4. Находим минимум суммы двух ячеек в двух соседних столбцов $\Rightarrow$ получили индекс $i$ из леммы 2.
5. Рекурсивно запускаемся для $s_1[1:i]$ и $s_{2_1}$, $s_1[i+1:n]$ и $s_{2_2}$.

Анализ времени: сначала нужно заполнить таблицу, второй раз нужно заполнить половину исходной таблицы: $T(n) = |s_1| \cdot |s_2| + \frac{|s_1| \cdot |s_2|}{2} + \frac{|s_1| \cdot |s_2|}{4} + \ldots \approx 2\cdot |s_1| \cdot |s_2|$.

Как восстановить выравнивание по этим парам индексов $(i, j)$?  

Для примера ниже пары это $(1, 0), (2, 0), (3, 1), (4, 2), ...$ — индексы начала строк, ноль — нет буквы.

```
É X P O Ń É N T - I A L
- - P O L Y N O M I A L
```

Такой подход к алгоритмам называется meet-in-the-middle — решаем не с одного конца, а с двух и где-то посередине находим нужное нам решение.
