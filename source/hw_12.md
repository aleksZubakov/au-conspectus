## Минимальные остовные/покрывающие деревья (minimal spaning tree)

### Теорема о разрезе

Пусть $T \subset M$, $M$ -- MST ($T$ -- остовный лес). $V = V_1 \sqcup V_2$ -- разрез $T$, не пересекающий ребер $T$.

**Утверждение:** пусть $e$ -- минимальное ребро, пересекающее разрез. $T\cup \{e\} \subset M'$, $M'$ -- тоже MST.

**Доказательство:** пусть это не так. Тогда рассмотрим $M$, $e\notin M$. Пусть $H = M\cup \{e\}$. В $H$ есть цикл (т.к. $M$ это уже остовное дерево) $\Rightarrow \exists e'$, ребро, пересекающее разрез, $\omega(e) < \omega(e') \Rightarrow$ если выкинуть из дерева $e'$ и добавить $e$, мы уменьшим вес дерева. Т.е. есть MST $M'' = H \setminus \{e'\}$ весит меньше, чем $M, \ \ T\subset M'', \ \ e\in M''$.

### Алгоритм Прима

Берем минимальное ребро. Дальше на каждом шаге мы к уже готовому дереву добавляем ребро, смежное с этим деревом.

Т.к. дерево покрывает все вершины, можно начать с дерева, содержащего только одну вершину (e.g. первую), и начать растить дерево с него.

По сути, Дейкстра с другой метрикой.

```python
def prim():
    dist = [inf for _ in range(n)]
    prev = [0 for _ in range(n)]

    pq = priority_queue()
    pq.insert((1, 0))
    while len(pq) > 0:
        v, d = q.extract_min()
        for u, w in g[v]:
            if dist[u] == inf:
                dist[u] = w
                prev[u] = v
                pq.insert(u, w)
            elif dist[u] > w:
                dist[u] = w
                prev[u] = v
                pq.decrease_key(u, w)

    T = ... # итоговое дерево
    for v in range(1, n):
        T += (prev[v], v)

    return T
```

**Сложность алгоритма:** такая же, как и у Дейкстры:
1. $O(V^2)$ -- очередь на массиве
2. $O(V+E\log(V))$ -- очередь на бинарной куче
3. $O(E)$, если $E\sim V^{1+\varepsilon}$ -- очередь на d-ичной куче.

### Алгоритм Краскала

Изначально есть остовный лес из $n$ вершин, без ребер. Растим его, на каждом шаге добавляя ребро с минимальным весом, концы которого лежат в разных деревьях.

Используем *систему непересекающихся множеств*, описание `make_set`, `find` и `union` см. ниже.

```python
def kruskal():
    es.sort(key=lambda e: e.w)  # es -- множество ребер
    for v in range(n):
         make_set(v)
    T = ...  # дерево
    for e in es:
        s1 = find(e.v)
        s2 = find(e.u)
        if s1 != s2:
            union(s1, s2)
            T += e

    return T
```

**Сложность алгоритма:** если веса ребер из целочисленного диапазано, то отсортировать их за $O(E)$, также ребра могут быть заранее отсортированы. В таком случае алгоритм будет работать за $O(V + E\log^*V)$

#### Система непересекающихся множеств (Disjoint sets)

**Операции:**
```python
make_set(v)   # создание нового множества
find(v)       # принимает вершину и возвращает  представителя его множества
union(s1, s2) # объединяет два множества
```

**Реализация:**
```python
parent = [None for _ in range(n)]
rank = [0 for _ in range(n)]  # высота дерева множества

# O(1)
def make_set(v):
    parent[v] = v
    rank[v] = 0

def find(v):
    while v !=  parent[v]:
        v = parent[v]
    return v

#O(1)
def union(s1, s2):
    if rank[s1] > rank[s2]:
        parent[s2] = s1
    elif rank[s1] < rank[s2]:
        parent[s1] = s2
    else:
        parent[s1] = s2
        rank[s2] += 1
```
