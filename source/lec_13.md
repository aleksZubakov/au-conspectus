**Утверждение:** у корня с рангом $k$ не менее, чем $2^k-1$ потомка (у соотв. множества не менее, чем $2^k$ элементов).
**Док-во:** по индукции. База очевидна. И.п.: есть два корня с не менее чем $2^k-1$ потомками, из реализации видно, что ранг у корня объединения будет не менее $(2^k-1) + (2^k-1) + 1 = 2^{k+1} - 1$.

Аналогично можно доказать, что у дерева с корнем ранга $k$ глубина равняется $k$.

**Следствие:** `find` для СНМ с рангами работает за $O(\log n)$.

##### Эвристика сжатия пути

```python
# O(log n)
def find(v):
    if v !=  parent[v]:
        parent[v] = find(parent[v])
    return v
```

Замечания:
1. Ранги не соответствуют высоте дерева
2. Утверждение про минимальное количество элементов в дереве осталось верным
3. Если вершина перестала быть корневой, то ее ранг зафиксировался и больше не изменится
4. Ранг вершины может только увеличиваться
5. `rank[parent[v]] > rank[v]`

**Утверждение:** вершин ранга $k$ не более, чем $\frac n {2^k}$.

**Время работы:** Предположим, что мы делаем $m\geq n$ операций `find` на СНМ размера $n$. Эти $m$ вызовов `find` требуют $O(m\cdot\log^* n)$ операций $\Rightarrow$ амортизированное время работы `find` -- $O(\log^* n)$
**Доказательство:** разобьем ранги на промежутки $[0], [1], [2], [3, 2^2], [5, 6,..., 2^4], [16+1,...,2^{16}], [65537,...,2^{65536}],...,[k+1,...,2^k]$.
Этих промежутков $\log^* n$ штук.

В СНМ есть два типа ребер -- внутренние и внешние. Внутреннее ребро -- `rank[v]` и `rank[parent[v]]` лежат в одном промежутке. Внешнее ребро -- ранги в разных промежутках.
`find` может заменить внутреннее на внешнее, но не обратно.

Утверждение: в каждой рекурсивной цепочке `find` не более $\log^* n$ внешних ребер (т.к. больше промежутков нет).

Утверждение: любая вершина ранга из промежутка $[k+1,...,2^k]$ учавствует в не более чем $2^k$ переходов по внутренним ребрам (больше значений в промежутке нету).

Утверждение: в каждом промежутке происходит не более $n$ переходов по внутренним ребрам: промежутко $[k+1,...,2^k]$; переходов: $\sum\limits_{i=k+1}^{2^k\approx \infty} 2^k\cdot \frac n {2^i} = \frac n 2 + \frac n 4 + \frac n 8 + ... \leq n$.

Итого: $m$ операций `find`.
Число переходов по ребрам: $m$ переходов по верхним ребрам, $m\cdot\log^* n$ переходов по внешним ребрам, $n\cdot\log^* n$ переходов по внутренним ребрам $=O(m\log^* n)$.
